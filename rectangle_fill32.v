// Copyright (C) 2023 Victor Suarez Rovere <suarezvictor@gmail.com>
// SPDX-License-Identifier: AGPL-3.0-only
//
// ** Autogenerated file **


module M_accel_rectangle_fill32 (
        in_bus_ack,
        in_bus_dat_r,
        in_x0,
        in_x1,
        in_y0,
        in_y1,
        in_rgba,
        in_base,
        in_xstride,
        in_ystride,
        out_bus_cyc,
        out_bus_stb,
        out_bus_adr,
        out_bus_we,
        out_bus_dat_w,
        out_bus_sel,
        in_run,
        out_done,
        reset,
        out_clock,
        clock
    );
    input  [0:0] in_bus_ack;
    input  [31:0] in_bus_dat_r;
    input  [15:0] in_x0;
    input  [15:0] in_x1;
    input  [15:0] in_y0;
    input  [15:0] in_y1;
    input  [31:0] in_rgba;
    input  [31:0] in_base;
    input signed [15:0] in_xstride;
    input signed [15:0] in_ystride;
    output  [0:0] out_bus_cyc;
    output  [0:0] out_bus_stb;
    output  [31:0] out_bus_adr;
    output  [0:0] out_bus_we;
    output  [31:0] out_bus_dat_w;
    output  [15:0] out_bus_sel;
    input in_run;
    output out_done;
    input reset;
    output out_clock;
    input clock;
    assign out_clock = clock;

    reg  [31:0] _d_yaddr;
    reg  [31:0] _q_yaddr;
    reg  [15:0] _d_x;
    reg  [15:0] _q_x;
    reg  [15:0] _d_y;
    reg  [15:0] _q_y;
    reg  [0:0] _d_bus_cyc;
    reg  [0:0] _q_bus_cyc;
    reg  [0:0] _d_bus_stb;
    reg  [0:0] _q_bus_stb;
    reg  [31:0] _d_bus_adr;
    reg  [31:0] _q_bus_adr;
    reg  [0:0] _d_bus_we;
    reg  [0:0] _q_bus_we;
    reg  [31:0] _d_bus_dat_w;
    reg  [31:0] _q_bus_dat_w;
    reg  [15:0] _d_bus_sel;
    reg  [15:0] _q_bus_sel;
    reg  [2:0] _d__idx_fsm0,_q__idx_fsm0;
    assign out_bus_cyc = _q_bus_cyc;
    assign out_bus_stb = _q_bus_stb;
    assign out_bus_adr = _q_bus_adr;
    assign out_bus_we = _q_bus_we;
    assign out_bus_dat_w = _q_bus_dat_w;
    assign out_bus_sel = _q_bus_sel;
    assign out_done = (_q__idx_fsm0 == 0)
           ;



`ifdef FORMAL
    initial begin
        assume(reset);
    end
    assume property($initstate || (in_run || out_done));
`endif
    always @* begin
        _d_yaddr = _q_yaddr;
        _d_x = _q_x;
        _d_y = _q_y;
        _d_bus_cyc = _q_bus_cyc;
        _d_bus_stb = _q_bus_stb;
        _d_bus_adr = _q_bus_adr;
        _d_bus_we = _q_bus_we;
        _d_bus_dat_w = _q_bus_dat_w;
        _d_bus_sel = _q_bus_sel;
        _d__idx_fsm0 = _q__idx_fsm0;
        // _always_pre
        (* full_case *)
        case (_q__idx_fsm0)
            1: begin
                // _top
                // __block_1
                _d_bus_cyc = 0;

                _d_bus_stb = 0;

                _d_bus_sel = 65535;

                // __block_2
                _d_yaddr = in_base;

                _d_y = in_y0;

                _d__idx_fsm0 = 2;
            end
            2: begin
                // __while__block_3
                if (_q_y<in_y1) begin
                    // __block_4
                    // __block_6
                    // __block_7
                    _d_bus_adr = (_q_yaddr);

                    _d_x = in_x0;

                    _d__idx_fsm0 = 4;
                end else begin
                    _d__idx_fsm0 = 0;
                end
            end
            4: begin
                // __while__block_8
                if (_q_x<in_x1) begin
                    // __block_9
                    // __block_11
                    // __block_12
                    _d_bus_dat_w = in_rgba;

                    _d_bus_we = 1;

                    _d_bus_stb = 1;

                    _d_bus_cyc = 1;

                    // __block_13
                    if (!((_d_bus_stb&&_d_bus_we)&&!(_d_bus_stb&&in_bus_ack&&_d_bus_we))) begin
                        // __block_14
                        // __block_16
                        _d_bus_stb = 0;

                        _d_bus_adr = (_q_bus_adr+(in_xstride));

                        _d_x = _q_x+1;

                        // __block_17
                    end else begin
                        // __block_15
                    end
                    // __block_18
                    // __block_19
                    _d__idx_fsm0 = 4;
                end else begin
                    _d__idx_fsm0 = 5;
                end
            end
            3: begin
                // __block_5
                _d__idx_fsm0 = 0;
            end
            5: begin
                // __while__block_20
                if (((_q_bus_stb&&_q_bus_we)&&!(_q_bus_stb&&in_bus_ack&&_q_bus_we))) begin
                    // __block_21
                    // __block_23
                    // __block_24
                    _d__idx_fsm0 = 5;
                end else begin
                    _d__idx_fsm0 = 6;
                end
            end
            6: begin
                // __block_22
                // __block_25
                _d_bus_cyc = 0;

                _d_bus_stb = 0;

                // __block_26
                _d_yaddr = _q_yaddr+in_ystride;

                // __block_27
                _d_y = _q_y+1;

                // __block_28
                _d__idx_fsm0 = 2;
            end
            0: begin
            end
            default: begin
                _d__idx_fsm0 = {3{1'bx}};
`ifdef FORMAL
                assume(0);
`endif
            end
        endcase
        // _always_post
        // pipeline stage triggers
    end

    always @(posedge clock) begin
        _q_yaddr <= _d_yaddr;
        _q_x <= _d_x;
        _q_y <= _d_y;
        _q_bus_cyc <= _d_bus_cyc;
        _q_bus_stb <= _d_bus_stb;
        _q_bus_adr <= _d_bus_adr;
        _q_bus_we <= _d_bus_we;
        _q_bus_dat_w <= _d_bus_dat_w;
        _q_bus_sel <= _d_bus_sel;
        _q__idx_fsm0 <= reset ? 0 : ( ~in_run ? 1 : _d__idx_fsm0);
    end

endmodule

