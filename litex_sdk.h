//autogenedated by: cat litex_sdk/*.h | grep -v "\#include \""
//
// This file is Copyright (c) 2025 Victor Suarez Rovere <suarezvictor@gmail.com>
// License: BSD-2-Clause

#ifndef STATIC_ASSERT
//TODO: move to a more general place
//https://stackoverflow.com/questions/3385515/static-assert-in-c
#define STATIC_ASSERT(COND,MSG) typedef char static_assertion_##MSG[(!!(COND))*2-1]
#define LITEX_STATIC_ASSERT3(X,L) STATIC_ASSERT(X,static_assertion_at_line_##L)
#define LITEX_STATIC_ASSERT2(X,L) LITEX_STATIC_ASSERT3(X,L)
#define LITEX_STATIC_ASSERT(X)    LITEX_STATIC_ASSERT2(X,__LINE__)
#endif

#define LITEX_PACKED32 __attribute__((packed, aligned(4)))

//general defitions and helpers for CSR access

#include <stdint.h>
#include <generated/csr.h>
typedef int litepheripheral_id;

typedef volatile uint32_t csr1word_t; //one 32-bit word (NOTE: MEMORY MAPPED IO NEEDS VOLATILE QUALIFIER)
typedef volatile uint64_t csr2word_t; //two 32-bit words (NOTE: MEMORY MAPPED IO NEEDS VOLATILE QUALIFIER)
#define LITECSR_T(s) csr ## s ## word_t //macro for selecting 64-bit or 32-bit registers based on size defintions in csr.h
#define LITECSR(s) LITECSR_T(s) //indirect use does macro expansion prior to concatenation

static inline csr2word_t csr_swap_words(csr2word_t x) { return (x >> 32) | (x << 32); } 
static inline csr2word_t litecsr_adjust_csr2(csr2word_t x) { return csr_swap_words(x); } //64-bit values are inverted
static inline csr1word_t litecsr_adjust_csr1(csr1word_t x) { return x; }

#define LITECSR_ACCESS_(v, sz) litecsr_adjust_csr ## sz (v)
#define LITECSR_ACCESS(v, sz) LITECSR_ACCESS_(v, sz)
#define LITECSR_READ(ph, s, field) LITECSR_ACCESS((s)->field, ph ## _ ## field ## _SIZE)
#define LITECSR_WRITE(ph, s, field, v) (s)->field = LITECSR_ACCESS(v, ph ## _ ## field ## _SIZE)

#define LITEX_OFFSET_ASSERT(ph, t, f) LITEX_STATIC_ASSERT(offsetof(t, f) == ph ## _ ## f ## _ADDR - ph ## _BASE);

////////////////////////////////////////////////////////////
//FIXME: this source should be autogenerated (i.e. in csr.h)
////////////////////////////////////////////////////////////
#ifndef __LITESDK_CSR_DEFS__H_
#define __LITESDK_CSR_DEFS__H_

#ifndef __cplusplus
#include <stdbool.h>
#endif



#ifndef LITEX_ALWAYS_INLINE
#define LITEX_ALWAYS_INLINE inline //__attribute__((always_inline))
#endif

////////////////////////////////////////////////////////////
//supported peripherals
////////////////////////////////////////////////////////////

//IMPORTANT NOTES:
// 1) register should be 'volatile' (since memory-mapped IO should never be cached by the compiler as sometimes are regular variables)
// macro LITEX_OFFSET_ASSERT can be used to check at compile time if the offset for the registers matches the definition in csr.h
// 2) structures should be *packed* at 32-bit boundaries (since 64-bit registers sometimes are not aligned to 8-byte boundaries)
// macro LITEX_PACKED32 should be used in structure definitions (only GCC support for now)


///////////////////////////////
// Timer
///////////////////////////////

#ifdef CSR_TIMER0_BASE
#define LITETIMER_ENABLED
#define LITETIMER_READ(s, field)		LITECSR_READ(CSR_TIMER0, s, field)
#define LITETIMER_WRITE(s, field, v)		LITECSR_WRITE(CSR_TIMER0, s, field, v)
typedef LITECSR(CSR_TIMER0_LOAD_SIZE) 		litetimer_load_t;
typedef LITECSR(CSR_TIMER0_RELOAD_SIZE)		litetimer_reload_t;
typedef LITECSR(CSR_TIMER0_EN_SIZE)		litetimer_en_t;
typedef LITECSR(CSR_TIMER0_UPDATE_VALUE_SIZE)	litetimer_update_value_t;
typedef LITECSR(CSR_TIMER0_VALUE_SIZE)		litetimer_value_t;
typedef LITECSR(CSR_TIMER0_EV_STATUS_SIZE)	litetimer_ev_status_t;
typedef LITECSR(CSR_TIMER0_EV_PENDING_SIZE)	litetimer_ev_pending_t;
typedef LITECSR(CSR_TIMER0_EV_ENABLE_SIZE)	litetimer_ev_enable_t;
#ifdef CSR_TIMER0_UPTIME_LATCH_ADDR
typedef LITECSR(CSR_TIMER0_UPTIME_LATCH_SIZE)   litetimer_uptime_latch_t;
typedef LITECSR(CSR_TIMER0_UPTIME_CYCLES_SIZE)  litetimer_uptime_cycles_t; //2 words
#endif


typedef struct LITEX_PACKED32 //fields arrangement must mach order to get exact peripheral layout
{
  litetimer_load_t		LOAD;
  litetimer_reload_t		RELOAD;
  litetimer_en_t		EN;
  litetimer_update_value_t	UPDATE_VALUE;
  litetimer_value_t		VALUE;
  litetimer_ev_status_t		EV_STATUS;
  litetimer_ev_pending_t	EV_PENDING;
  litetimer_ev_enable_t		EV_ENABLE;
#ifdef CSR_TIMER0_UPTIME_LATCH_ADDR
  litetimer_uptime_latch_t	UPTIME_LATCH;
  litetimer_uptime_cycles_t	UPTIME_CYCLES;
#endif
} volatile litetimer_t;


//offset checking
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, LOAD);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, RELOAD);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, UPDATE_VALUE);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, VALUE);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, EV_STATUS);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, EV_PENDING);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, EV_ENABLE);
#ifdef CSR_TIMER0_UPTIME_LATCH_ADDR
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, UPTIME_LATCH);
LITEX_OFFSET_ASSERT(CSR_TIMER0, litetimer_t, UPTIME_CYCLES);
#endif
#endif //CSR_TIMER0_BASE


///////////////////////////////
// GPIO
///////////////////////////////

#ifdef CSR_GPIO_BASE
#define LITEGPIO_ENABLED
#define LITEGPIO_READ(s, field)		LITECSR_READ(CSR_GPIO, s, field)
#define LITEGPIO_WRITE(s, field, v)	LITECSR_WRITE(CSR_GPIO, s, field, v)
typedef LITECSR(CSR_GPIO_OE_SIZE)	litegpio_oe_t;
typedef LITECSR(CSR_GPIO_IN_SIZE)	litegpio_in_t;
typedef LITECSR(CSR_GPIO_OUT_SIZE)	litegpio_out_t;

typedef struct LITEX_PACKED32 //fields arrangement must mach order to get exact peripheral layout
{
  litegpio_oe_t		OE;
  litegpio_in_t		IN;
  litegpio_out_t	OUT;
} volatile litegpio_t;

//offset checking
LITEX_OFFSET_ASSERT(CSR_GPIO, litegpio_t, OE);
LITEX_OFFSET_ASSERT(CSR_GPIO, litegpio_t, IN);
LITEX_OFFSET_ASSERT(CSR_GPIO, litegpio_t, OUT);
#endif //CSR_GPIO_BASE

///////////////////////////////
// DMA Writer
///////////////////////////////

#ifdef CSR_DMA_WRITER_BASE
#define LITEDMA_WRITER_ENABLED
#define LITEDMAWRITER_READ(s, field)		LITECSR_READ(CSR_DMA_WRITER, s, field)
#define LITEDMAWRITER_WRITE(s, field, v)	LITECSR_WRITE(CSR_DMA_WRITER, s, field, v)
typedef LITECSR(CSR_DMA_WRITER_BASE_SIZE) 	litedma_writer_base_t;
typedef LITECSR(CSR_DMA_WRITER_LENGTH_SIZE)	litedma_writer_length_t;
typedef LITECSR(CSR_DMA_WRITER_ENABLE_SIZE)	litedma_writer_enable_t;
typedef LITECSR(CSR_DMA_WRITER_DONE_SIZE)	litedma_writer_done_t;
typedef LITECSR(CSR_DMA_WRITER_LOOP_SIZE)	litedma_writer_loop_t;
typedef LITECSR(CSR_DMA_WRITER_OFFSET_SIZE)	litedma_writer_offset_t;

typedef struct LITEX_PACKED32 //fields arrangement must mach order to get exact peripheral layout
{
  litedma_writer_base_t		BASE;
  litedma_writer_length_t	LENGTH;
  litedma_writer_enable_t	ENABLE;
  litedma_writer_done_t 	DONE;
  litedma_writer_loop_t 	LOOP;
  litedma_writer_offset_t	OFFSET;
} volatile litedma_writer_t;
//TODO: do offset checking with macro LITEX_OFFSET_ASSERT

#endif //CSR_DMA_WRITER_BASE


///////////////////////////////
// DMA Reader
///////////////////////////////

#ifdef CSR_DMA_READER_BASE
#define LITEDMA_READER_ENABLED
#define LITEDMAREADER_READ(s, field)		LITECSR_READ(CSR_DMA_READER, s, field)
#define LITEDMAREADER_WRITE(s, field, v)	LITECSR_WRITE(CSR_DMA_READER, s, field, v)
typedef LITECSR(CSR_DMA_READER_BASE_SIZE) 	litedma_reader_base_t;
typedef LITECSR(CSR_DMA_READER_LENGTH_SIZE)	litedma_reader_length_t;
typedef LITECSR(CSR_DMA_READER_ENABLE_SIZE)	litedma_reader_enable_t;
typedef LITECSR(CSR_DMA_READER_DONE_SIZE)	litedma_reader_done_t;
typedef LITECSR(CSR_DMA_READER_LOOP_SIZE)	litedma_reader_loop_t;
typedef LITECSR(CSR_DMA_READER_OFFSET_SIZE)	litedma_reader_offset_t;

typedef struct LITEX_PACKED32 //fields arrangement must mach order to get exact peripheral layout
{
  litedma_reader_base_t		BASE;
  litedma_reader_length_t	LENGTH;
  litedma_reader_enable_t	ENABLE;
  litedma_reader_done_t		DONE;
  litedma_reader_loop_t		LOOP;
  litedma_reader_offset_t	OFFSET;
} volatile litedma_reader_t;
//TODO: do offset checking with macro LITEX_OFFSET_ASSERT

#endif //CSR_DMA_READER_BASE

#endif //__LITESDK_CSR_DEFS__H_
// This file is Copyright (c) 2025 Victor Suarez Rovere <suarezvictor@gmail.com>
// License: BSD-2-Clause

#ifndef __LITESDK_GPIO_H_
#define __LITESDK_GPIO_H_


/*
Basic API
typedef litegpio_pin_t //pin number

litegpio_mode_input()
litegpio_mode_output()
litegpio_mode_open_drain()
litegpio_set_low()
litegpio_set_high()
litegpio_read()
litegpio_write()
litegpio_od_low() //open drain
litegpio_od_high() //open drain
litegpio_init()
litegpio_deinit()

Instance argument can be the predefined litegpio0 (corresponds to main GPIO), for example:
litegpio_set_low(litegpio0, 0);

*/


///////////////////////////////
// GPIO 
///////////////////////////////

//this defintion is required even of GPIO core is not used
//to avoid compilations errors at various micropython' sources
typedef uint8_t litegpio_pin_t;

#ifdef LITEGPIO_ENABLED


#if CSR_GPIO_OE_SIZE > 1
#warning GPIO of 64-bits needs testing!
#endif


typedef litegpio_out_t csr_gpio_t;
#define litegpio0 ((litegpio_t *) CSR_GPIO_BASE)
//static const litegpio_t *litegpio0 = (litegpio_t *) CSR_GPIO_BASE;


#define csr_1 ((csr_gpio_t)1)
#define csr_pin_set(v, p) ((v) | (csr_1 << (p)))
#define csr_pin_clear(v, p) ((v) & ~(csr_1 << (p)))
#define csr_pin_read(v, p) (((v) & (csr_1 << (p))) != 0)


static LITEX_ALWAYS_INLINE void litegpio_mode_input(litegpio_t *gpio, litegpio_pin_t pin)
{
  gpio->OE = csr_pin_clear(gpio->OE, pin); //gpio_oe_write(csr_pin_clear(gpio_oe_read(), pin));
}

static LITEX_ALWAYS_INLINE void litegpio_mode_output(litegpio_t *gpio, litegpio_pin_t pin)
{
  gpio->OE = csr_pin_set(gpio->OE, pin); //gpio_oe_write(csr_pin_set(gpio_oe_read(), pin));
}

static LITEX_ALWAYS_INLINE void litegpio_set_low(litegpio_t *gpio, litegpio_pin_t pin)
{
  gpio->OUT = csr_pin_clear(gpio->OUT, pin); //gpio_out_write(csr_pin_clear(gpio_out_read(), pin));
}

static LITEX_ALWAYS_INLINE void litegpio_set_high(litegpio_t *gpio, litegpio_pin_t pin)
{
  gpio->OUT = csr_pin_set(gpio->OUT, pin); //gpio_out_write(csr_pin_set(gpio_out_read(), pin));
}

static LITEX_ALWAYS_INLINE bool litegpio_read(litegpio_t *gpio, litegpio_pin_t pin)
{
  return csr_pin_read(gpio->IN, pin); //csr_pin_read(gpio_in_read(), pin);
}

static LITEX_ALWAYS_INLINE void litegpio_write(litegpio_t *gpio, litegpio_pin_t pin, bool value)
{
  //FIXME: write a more time-deterministic implementation, for example:
  //#define csr_pin_write(v, p, bit) (csr_pin_clear(v, p) | (((csr_gpio_t)(bit)) << (p)))
  //OR as in http://graphics.stanford.edu/~seander/bithacks.html#MaskedMerge
  //#define csr_pin_write(v, p, bit) ((v) ^ (((v) ^ (csr_1 << (p))) & (((csr_gpio_t)(bit)) << (p))); 

 if(value) 
    litegpio_set_high(gpio, pin);
  else
    litegpio_set_low(gpio, pin);
}

//open drain functions
//FIXME: current implementations only controls Z (output enable) of a pin always set at LOW

static LITEX_ALWAYS_INLINE void litegpio_mode_open_drain(litegpio_t *gpio, litegpio_pin_t pin)
{
  litegpio_set_low(gpio, pin);
  litegpio_mode_input(gpio, pin);
}

static LITEX_ALWAYS_INLINE void litegpio_od_low(litegpio_t *gpio, litegpio_pin_t pin)
{
  litegpio_mode_output(gpio, pin);
}

static LITEX_ALWAYS_INLINE void litegpio_od_high(litegpio_t *gpio, litegpio_pin_t pin)
{
  litegpio_mode_input(gpio, pin);
}


//helpers

static LITEX_ALWAYS_INLINE void litegpio_init(litegpio_t *gpio)
{
  (void) gpio;
}

static LITEX_ALWAYS_INLINE void litegpio_deinit(litegpio_t *gpio)
{
  (void) gpio;
}

//lookups base address from a pheripheral id (0, 1, 2...)
static LITEX_ALWAYS_INLINE litegpio_t *litegpio_instance(litepheripheral_id id)
{
  if(id != 0) //only supports single gpio
    return NULL; 
  return litegpio0;
}

#endif //LITEGPIO_ENABLED

#endif //__LITESDK_GPIO_H_

// This file is Copyright (c) 2025 Victor Suarez Rovere <suarezvictor@gmail.com>
// License: BSD-2-Clause

#ifndef __LITESDK_TIMER_H_
#define __LITESDK_TIMER_H_
#include <stddef.h>


/*
Basic API
typedef litetimer_value_t

litetimer_set_oneshot_cycles()
litetimer_set_periodic_cycles()
litetimer_start()
litetimer_stop()
litetimer_is_active()
litetimer_is_periodic()
litetimer_get_value_cycles()
litetimer_get_value_ms()
litetimer_get_value_us()
litetimer_get_value_ns()
litetimer_get_frequency()

litetimer_freq_to_cycles()
litetimer_freqf_to_cycles() //float version
litetimer_ns_to_cycles()
litetimer_us_to_cycles()
litetimer_ms_to_cycles()
litetimer_cycles_to_ns()
litetimer_cycles_to_us()
litetimer_cycles_to_ms()

*/

///////////////////////////////
// TIMER 
///////////////////////////////
#ifdef LITETIMER_ENABLED


//conversion functions
#define LITETIMER_BASE_FREQUENCY CONFIG_CLOCK_FREQUENCY
#define LITETIMER_BASE_FREQUENCY64 ((uint64_t)LITETIMER_BASE_FREQUENCY)
#define LITETIMER_CYCLES_FROM_FREQ64(f) (litetimer_value_t) (LITETIMER_BASE_FREQUENCY64 / (f))
#define LITETIMER_CYCLES_FROM_PERIOD64(t, divfactor) (litetimer_value_t) (LITETIMER_BASE_FREQUENCY64*(t)/divfactor)
#define LITETIMER_PERIOD_FROM_CYCLES64(c, mult) (litetimer_value_t) (c*(uint64_t)mult/LITETIMER_BASE_FREQUENCY)

//TODO: provide
static inline litetimer_value_t litetimer_freqf_to_cycles(const litetimer_t *tim, float freq)
{
  (void) tim;
  return LITETIMER_CYCLES_FROM_FREQ64(freq);
}

static inline litetimer_value_t litetimer_freq_to_cycles(const litetimer_t *tim, uint32_t freq)
{
  (void) tim;
  return LITETIMER_CYCLES_FROM_FREQ64(freq);
}

static inline litetimer_value_t litetimer_ms_to_cycles(const litetimer_t *tim, uint32_t period_ms)
{
  (void) tim;
  return LITETIMER_CYCLES_FROM_PERIOD64(period_ms, 1000);
}

static inline litetimer_value_t litetimer_us_to_cycles(const litetimer_t *tim, uint32_t period_us)
{
  (void) tim;
  return LITETIMER_CYCLES_FROM_PERIOD64(period_us, 1000000);
}

static inline litetimer_value_t litetimer_ns_to_cycles(const litetimer_t *tim, uint32_t period_ns)
{
  (void) tim;
  return LITETIMER_CYCLES_FROM_PERIOD64(period_ns, 1000000000ull);
}

static inline uint32_t litetimer_cycles_to_ms(const litetimer_t *tim, litetimer_value_t cycles)
{
  (void) tim;
  return LITETIMER_PERIOD_FROM_CYCLES64(cycles, 1000);
}


static inline uint32_t litetimer_cycles_to_us(const litetimer_t *tim, litetimer_value_t cycles)
{
  (void) tim;
  return LITETIMER_PERIOD_FROM_CYCLES64(cycles, 1000000);
}

//getters projectors
/*
static uint32_t litetimer_get_frequency(const litetimer_t *tim)
{
  (void) tim;
  return LITETIMER_BASE_FREQUENCY;
}
*/
#define litetimer_get_frequency(tim) LITETIMER_BASE_FREQUENCY
#define litetimer0 (litetimer_t *) CSR_TIMER0_BASE


static inline litetimer_value_t litetimer_get_value_cycles(const litetimer_t *tim)
{
  ((litetimer_t *)tim)->UPDATE_VALUE = 1; //const removal
  return LITETIMER_READ(tim, VALUE);
}

static inline litetimer_value_t litetimer_get_value_us(const litetimer_t *tim)
{
  return litetimer_cycles_to_us(tim, litetimer_get_value_cycles(tim));
}

static inline litetimer_value_t litetimer_get_value_ms(const litetimer_t *tim)
{
  return litetimer_cycles_to_ms(tim, litetimer_get_value_cycles(tim));
}

static inline bool litetimer_is_active(const litetimer_t *tim)
{
  return tim->EN;
}

static inline bool litetimer_is_periodic(const litetimer_t *tim)
{
  return !LITETIMER_READ(tim, LOAD); //LOAD is 0 in periodic timers
}

//setters projectors
static inline void litetimer_start(litetimer_t *tim)
{
  tim->EN = 1;
}

static inline void litetimer_stop(litetimer_t *tim)
{
  tim->EN = 0;
}

//needs to be start after call
static inline void litetimer_set_periodic_cycles(litetimer_t *tim, litetimer_load_t cycles)
{
/* As documented on gateware:
   To use the Timer in Periodic mode, the user needs to:
    - Disable the Timer
    - Set the ``load`` register to 0
    - Set the ``reload`` register to the expected period
    - Enable the Timer
*/
  litetimer_stop(tim);
  LITETIMER_WRITE(tim, LOAD, 0);
  LITETIMER_WRITE(tim, RELOAD, cycles);
}

//needs to be start after call
static inline void litetimer_set_oneshot_cycles(litetimer_t *tim, litetimer_load_t cycles)
{
/* As documented on gateware:
   To use the Timer in One-Shot mode, the user needs to:
    - Disable the timer
    - Set the ``load`` register to the expected duration
    - (Re-)Enable the Timer
*/
  litetimer_stop(tim);
  LITETIMER_WRITE(tim, LOAD, cycles);
}

//helpers

static inline void litetimer_init(litetimer_t *tim)
{
  litetimer_stop(tim);
}

static inline void litetimer_deinit(litetimer_t *tim)
{
  litetimer_stop(tim);
}

//lookups base address from a pheripheral id (0, 1, 2...)
static inline litetimer_t *litetimer_instance(litepheripheral_id id)
{
  if(id != 0) //only supports single timer
    return NULL; 
  return litetimer0;
}

#endif //LITETIMER_ENABLED

#endif //__LITESDK_TIMER_H_

